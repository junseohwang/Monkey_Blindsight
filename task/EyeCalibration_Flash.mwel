//////////////////////////////////////////////////////////////
// Platform + I/O
//////////////////////////////////////////////////////////////

var subject = 'monkey'
%define monkey_train               // default: EyeLink + reward
// %define laptop                  // alt: mouse only

%ifdef monkey_train
  %include 'hand_interfaces/keyboard'
  %include 'eye_interfaces/eyelink'         // defines eye_x, eye_y
  %include 'reward_interfaces/firmata_train'// defines reward_line
%end

%ifdef laptop
  %include 'hand_interfaces/keyboard'
  %include 'eye_interfaces/mouse'           // maps mouse to eye_x, eye_y
%end

//////////////////////////////////////////////////////////////
// Sounds (optional)
//////////////////////////////////////////////////////////////
resource ('sounds')
sound/wav_file success_sound ('sounds/success.wav')

//////////////////////////////////////////////////////////////
// Variables
//////////////////////////////////////////////////////////////

group Reward {
  var reward_line = 0 (groups = Reward)
  var reward_ms   = 150  (groups = Reward)   // reward duration (ms)
}

group Grid {
  // MODE: 1=center only, 2=cross (4 points), 3=full 3×3
  var grid_mode   = 1     (groups = Grid)

  var grid_cols   = 3
  var grid_rows   = 3
  var cell_spacing = 8    // distance (screen units) between grid cells

  var center_x    = 0
  var center_y    = 0

  var x_position = 0
  var y_position = 0

  // indices in [0,1,2] (0=-1 step, 1=0 step, 2=+1 step)
  var col_idx     = 1
  var row_idx     = 1

  // sequence counters
  var seq_index   = 0
  var seq_len     = 1
  var cycles      = 1     // # times to traverse the sequence
  var cycle_count = 0
}

group Fixation {
  var fix_sz      = 4
  var fix_win     = 25
  var eye_on      = 0

  var max_wait_ms = 10000    // response window
  var hold_ms     = 300      // required fixation hold
  var iti_ms      = 400
}

group Stats {
  var trials      = 0
  var hits        = 0
}

//////////////////////////////////////////////////////////////
// Stimulus
//////////////////////////////////////////////////////////////

circular_fixation_point cal_dot (
  color = 1,1,1
  trigger_width = fix_win
  trigger_watch_x = eye_x
  trigger_watch_y = eye_y
  trigger_flag   = eye_on
  x_size = fix_sz
  y_size = fix_sz
  x_position = 0
  y_position = 0
)

//////////////////////////////////////////////////////////////
// Helpers (as actions inside states)
//////////////////////////////////////////////////////////////

// Compute x,y from (row_idx,col_idx) and center/spacing
// Note: row 0 = top, row 2 = bottom  => y flips sign
// col 0 = left, col 2 = right
// Use these assignments wherever we “move” the dot:
///  cal_dot.x_position = center_x + (col_idx - 1) * cell_spacing
///  cal_dot.y_position = center_y + (1 - row_idx) * cell_spacing

//////////////////////////////////////////////////////////////
// Protocol
//////////////////////////////////////////////////////////////

protocol 'Calib_Grid' {
  start_device_io (eye_tracker)
  start_io_device (firmata)

  queue_stimulus (cal_dot)
  update_stimulus_display ()

  task Trials {

    //////////////////////////////////////////////////////////
    // Initialize sequence based on grid_mode
    //////////////////////////////////////////////////////////
    state 'Init' {
      trials      = 0
      hits        = 0
      seq_index   = 0
      cycle_count = 0

      // set seq_len and starting (row,col)
      if (grid_mode == 1) {           // center only
        seq_len = 1
        row_idx = 1 
        col_idx = 1
      }
      if (grid_mode == 2) {           // cross (Up, Right, Down, Left)
        seq_len = 4
        row_idx = 0 
        col_idx = 1      // start at Up
      }
      if (grid_mode == 3) {           // full 3×3 (top-left start)
        seq_len = 9
        row_idx = 0 
        col_idx = 0
      }

      // place dot
      x_position = center_x + (col_idx - 1) * cell_spacing
      y_position = center_y + (1 - row_idx) * cell_spacing

      update_stimulus_display ()
      goto ('Wait Fix')
    }

    //////////////////////////////////////////////////////////
    // Wait for fixation within response window
    //////////////////////////////////////////////////////////
    state 'Wait Fix' {
      trials = trials + 1

      start_timer ( 
        timer = MaxWait
        duration = max_wait_ms 
        duration_units = ms 
        )
      goto ( 
        target = 'Hold'      
        when = eye_on 
        )
      timer_expired ( 
        target = 'Timeout' 
        timer = MaxWait 
        )
    }

    //////////////////////////////////////////////////////////
    // Require a steady hold to count as success
    //////////////////////////////////////////////////////////
    state 'Hold' {
      start_timer ( 
        timer = HoldT 
        duration = hold_ms 
        duration_units = ms 
        )
      goto ( 
        target = 'Break' 
        when = !eye_on 
        )
      timer_expired ( 
        target = 'Reward' 
        timer = HoldT 
        )
    }

    state 'Break' {
      goto ('Wait Fix')
    }

    //////////////////////////////////////////////////////////
    // Reward & move on
    //////////////////////////////////////////////////////////
    state 'Reward' {
      hits = hits + 1
      action/play_sound (success_sound)

      pulse ( 
        variable = reward_line 
        duration = reward_ms * 1000 
        )  // microseconds
      goto ('Advance')
    }

    state 'Timeout' {
      goto ('Advance')
    }

    //////////////////////////////////////////////////////////
    // Advance through the chosen sequence
    //////////////////////////////////////////////////////////
    state 'Advance' {
      // progress the sequence counter
      seq_index = seq_index + 1

      // finished this pass?
      goto ( 
        target = 'Cycle Done' 
        when = (seq_index >= seq_len) 
        )

      // otherwise set next (row,col) by mode
      if (grid_mode == 1) {
        // stays at center; nothing to change
      }

      if (grid_mode == 2) {
        // order: Up(0,1) → Right(1,2) → Down(2,1) → Left(1,0)
        if (seq_index == 0) { 
            row_idx = 0 
            col_idx = 1 
            }   // Up (already used at init)
        if (seq_index == 1) { 
            row_idx = 1 
            col_idx = 2 
            }   // Right
        if (seq_index == 2) { 
            row_idx = 2
            col_idx = 1
            }   // Down
        if (seq_index == 3) { 
            row_idx = 1
            col_idx = 0
            }   // Left
      }

      if (grid_mode == 3) {
        // left→right, top→bottom stepping
        if (col_idx < 2) {
          col_idx = col_idx + 1
        } 
        else {
          col_idx = 0
          if (row_idx < 2) { 
            row_idx = row_idx + 1 
            } 
          else { 
            row_idx = 0 
            }
        }
      }

      // move dot
      x_position = center_x + (col_idx - 1) * cell_spacing
      y_position = center_y + (1 - row_idx) * cell_spacing

      update_stimulus_display ()
      goto ('ITI')
    }

    state 'Cycle Done' {
      cycle_count = cycle_count + 1
      goto ( 
        target = 'Exit' 
        when = (cycle_count >= cycles) 
        )

      // reset for another pass
      seq_index = 0
      if (grid_mode == 1) { 
        row_idx = 1
        col_idx = 1
        }
      if (grid_mode == 2) { 
        row_idx = 0
        col_idx = 1
        }
      if (grid_mode == 3) { 
        row_idx = 0
        col_idx = 0
        }

      x_position = center_x + (col_idx - 1) * cell_spacing
      y_position = center_y + (1 - row_idx) * cell_spacing

      update_stimulus_display ()
      goto ('ITI')
    }

    //////////////////////////////////////////////////////////
    // ITI (dot stays visible; set to 0,0,0 if you want OFF)
    //////////////////////////////////////////////////////////
    state 'ITI' {
      start_timer ( 
        timer = ITI 
        duration = iti_ms 
        duration_units = ms 
        )
      timer_expired ( 
        target = 'Wait Fix' 
        timer = ITI 
        )
    }

    state 'Exit' {
      dequeue_stimulus (cal_dot)
      update_stimulus_display ()
      yield ()
    }
  }
}
